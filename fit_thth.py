import astropy.units as u
import numpy as np
import matplotlib.pyplot as plt
from glob import glob
import os, sys, math, time
from scipy import interpolate
from astropy.time import Time
from astropy.visualization import quantity_support

from astropy import constants as const

import astropy
from matplotlib.colors import LogNorm

import matplotlib as mpl
#import scintools.ththmod as THTH
from scipy.sparse.linalg import eigsh
from scipy.optimize import curve_fit

sys.path.insert(1, '/home/gusinskaia/scintools/scintools')
import ththmod as THTH
np.seterr(divide='ignore', invalid='ignore')


def eta_to_mu(eta, spec, deff):
    c_f=spec.f.mean()
    vel=(const.c/(2.*c_f**2.*deff*eta))**0.5*deff
    mu=(vel.decompose().to('km/s').value)*1e3/(4.74*deff.to(u.pc).value)
    return mu*u.mas/u.yr

def mu_to_eta(mu, spec, deff):
    c_f=spec.f.mean()
    vel=mu.value*4.74*deff.to(u.pc).value*1e-3
    vel=vel*u.km/u.s
    eta=deff*const.c/(2*c_f**2*vel**2)
    return eta.to(u.us/u.mHz**2)

def eta_to_dveff(eta, spec):
    c_f=spec.f.mean()
    dveff=(const.c/(2.*c_f**2.*eta))**0.5
    return dveff.decompose().to(u.km/(u.pc**0.5 *u.s))

def dveff_to_eta(dveff, spec):
    c_f=spec.f.mean()
    eta=const.c/(2*c_f**2*dveff**2)
    return eta.to(u.us/u.mHz**2)


def daniel_pars_fit(spec, curv_par='eta', etas_pars=[0.25,5.5,0.25], edge=1.4,ntau=512,
                       d_eff=0.325*u.kpc, npoints=100, chi2_method='Nina', reduced=True):
    print ('fit:', spec)
    etas_init=np.arange(etas_pars[0],etas_pars[1],etas_pars[2])
    edges=np.linspace(-edge,edge,ntau)
    
    eta_low=np.amin(etas_init)*u.us/(u.mHz**2)
    eta_high=np.amax(etas_init)*u.us/(u.mHz**2)
    
    if curv_par=='eta':
        pars2=np.linspace(eta_low.value,eta_high.value,npoints)*eta_low.unit
        etas2=pars2
        
    if curv_par=='mueff':
        mu_low=eta_to_mu(eta_high, spec, d_eff)
        mu_high=eta_to_mu(eta_low, spec, d_eff)
        pars2=np.linspace(mu_high.value,mu_low.value,npoints)*mu_low.unit
        etas2=mu_to_eta(pars2, spec, d_eff)

    if curv_par=='dveff':
        dveff_low=eta_to_dveff(eta_high, spec)
        dveff_high=eta_to_dveff(eta_low, spec)
        pars2=np.linspace(dveff_high.value,dveff_low.value,npoints)*dveff_low.unit
        etas2=dveff_to_eta(pars2, spec)
    
    chisq=np.zeros(pars2.shape[0])
    ntheta_reds=np.zeros(pars2.shape[0])
    N=spec.get_noise()
    edges=np.linspace(-edge,edge,ntau)
    mask=np.ones(spec.I.T.shape,dtype=bool)
    for i in range(pars2.shape[0]):
        eta=etas2[i]
        ##Fits a model generated by taking the outer product of the dominate eigenvector
        ##(in theta-theta space) and then mapping back to the dynamic spectrum
        if chi2_method == 'Daniel':
            chisq[i]=THTH.chisq_calc(spec.I.T,spec.ss.Is, spec.ss.tau, spec.ss.fd, eta, edges,mask,N)
        if chi2_method == 'Nina':
            chisq[i], ntheta_reds[i] = nina_get_chi2_spec(spec, eta, edge, ntau, reduced=reduced)

    ##Fit for a parabola around the minimum
    p_min=pars2[chisq==chisq.min()][0]
    fit_results=chisq[np.abs(pars2-p_min)<.1*p_min]
    C=fit_results.min()
    measure=chisq
        
    pars_fit=pars2[np.abs(pars2-p_min)<.1*p_min]
    x0=pars_fit[fit_results==C][0].value
    A=(fit_results[0]-C)/((pars_fit[0].value-x0)**2)
    try:
        popt,pcov=curve_fit(THTH.chi_par,pars_fit.value,fit_results,p0=np.array([A,x0,C]))
        par_fit=popt[1]*pars2.unit
        par_sig=np.sqrt((fit_results-THTH.chi_par(pars_fit.value,*popt)).std()/popt[0])*pars2.unit

    except RuntimeError:
        print('Fit curve didnt converge')
        par_fit, par_sig, popt=float('nan') , 0.0*pars_fit.unit,  0.0
    except TypeError:
        print ('Improper input: N=3 must not exceed M=1; -- tb fixed')
        par_fit, par_sig, popt=float('nan') , 0.0*etas_fit.unit,  0.0
        

    if np.isnan(par_fit):
        eta_fit, mueff_fit, dveff_fit=par_fit,par_fit,par_fit
        eta_sig, mueff_sig, dveff_sig=0.0*u.us/(u.mHz**2), 0.0*u.mas/u.yr, 0.0*u.km/(u.pc**0.5 *u.s)
    else:
        if curv_par=='mueff':
            mueff_fit=par_fit
            mueff_sig=par_sig
            eta_fit=mu_to_eta(par_fit, spec, d_eff)
            eta_sig=(2.*eta_fit/mueff_fit)*mueff_sig
            dveff_fit=eta_to_dveff(eta_fit, spec)
            dveff_sig=(0.5*dveff_fit/eta_fit)*eta_sig

        if curv_par=='dveff':
            dveff_fit=par_fit
            dveff_sig=par_sig
            eta_fit=dveff_to_eta(par_fit, spec)
            eta_sig=(2.*eta_fit/dveff_fit)*dveff_sig
            mueff_fit=eta_to_mu(eta_fit, spec, d_eff)
            mueff_sig=(0.5*mueff_fit/eta_fit)*eta_sig

        if curv_par=='eta':
            eta_fit, eta_sig= par_fit, par_sig
            mueff_fit=eta_to_mu(eta_fit, spec, d_eff)
            mueff_sig=(0.5*mueff_fit/eta_fit)*eta_sig
            dveff_fit=eta_to_dveff(eta_fit, spec)
            dveff_sig=(0.5*dveff_fit/eta_fit)*eta_sig
     
    fitdic={'eta':eta_fit, 'mueff':mueff_fit, 'dveff':dveff_fit, 'eta_err':eta_sig, 'mueff_err':mueff_sig,
              'dveff_err':dveff_sig, 'mean_f':np.mean(spec.f), 'mean_t':np.mean(spec.mjd.mjd)}
    
    res_dic={'par_array':pars2, 'fit_array':pars_fit, 'chi2':measure, 'fit_res':popt,
              'par_fit':par_fit, 'par_sig':par_sig, 'ntheta_red':ntheta_reds, 'mean_f':np.mean(spec.f), 'mean_t':np.mean(spec.mjd.mjd)}
    return fitdic, np.mean(spec.f), np.mean(spec.mjd.mjd), res_dic


def nina_get_chi2_spec(spec, eta, edge=1.4, ntau=512, fd2=None,tau2=None, plot_mds=False, reduced=True):
    chisq=nina_get_chi2(spec.I, spec.ss.Is, spec.ss.tau, spec.ss.fd, eta, edge, ntau, fd2, tau2, plot_mds, spec.nI, reduced=reduced)
    return chisq

def nina_get_chi2(ds, SS,tau,fd, eta, edge=1.4, ntau=512, fd2=None,tau2=None, plot_mds=False, ns=None,
reduced=True):
    edges=np.linspace(-edge,edge,ntau) 
    thth_red,thth2_red,recov,model,edges_red,w,V=THTH.modeler(SS,tau,fd, eta, edges, fd2, tau2)
    emin, emax=np.amin(edges_red), np.amax(edges_red)
    c=([(tau.value > emin)&(tau.value < emax) ])
    tau_red=tau[c]
    ndof=ds.size-tau_red.shape[0]*2-2#/(SS.shape[0]/ds.shape[1]) - 2
    #ndof=ds.size-thth_red.shape[0]*2 - 2
    if ns is None:
        ns=np.random.normal(size=np.shape(ds))*np.std(ds)/6
    if plot_mds is True:
        vmin, vmax=np.percentile(model, [1,99])
        plt.imshow(model, aspect='auto', vmin=vmin, vmax=vmax, origin='lower')
        plt.show()
    chisq=((model[:ds.T.shape[0],:ds.T.shape[1]]-ds.T)**2).sum()/np.mean(ns)**2
    if reduced is True:
        chisq=chisq/ndof
    #ntheta_red=thth_red.shape[0]
    ntheta_red=tau_red.shape[0]*2/(SS.shape[0]/ds.shape[1])
    return(chisq,ntheta_red)

